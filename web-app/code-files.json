{
  "AmazonMusic.py": "import random\r\n\r\nclass Song:\r\n    def __init__(self, title: str, artist: str, media_path: str):\r\n        self.title = title\r\n        self.artist = artist\r\n        self.media_path = media_path\r\n\r\n    def play(self):\r\n        print(f\"Playing {self.title} by {self.artist} from {self.media_path}\")\r\n\r\nclass SongLibrary:\r\n    def __init__(self):\r\n        self.songs = {}\r\n\r\n    def add_song(self, song: Song):\r\n        self.songs[song.title] = song\r\n\r\n    def get_song(self, title: str) -> Song:\r\n        return self.songs.get(title)\r\n\r\n    def get_all_songs(self):\r\n        return list(self.songs.values())\r\n\r\n# A singleton SongLibrary instance\r\nlibrary = SongLibrary()\r\n\r\nclass Playlist:\r\n    def __init__(self, name: str):\r\n        self.name = name\r\n        self.songs = []\r\n\r\n    def add_song(self, song: Song):\r\n        if library.get_song(song.title):\r\n            self.songs.append(song)\r\n\r\n    def play(self):\r\n        print(f\"Playing Playlist: {self.name}\")\r\n        for song in self.songs:\r\n            song.play()\r\n\r\nclass User:\r\n    def __init__(self, username: str):\r\n        self.username = username\r\n        self.playlists = {}\r\n\r\n    def create_playlist(self, name: str):\r\n        self.playlists[name] = Playlist(name)\r\n\r\n    def add_song_to_playlist(self, playlist_name: str, song: Song):\r\n        if playlist_name in self.playlists:\r\n            self.playlists[playlist_name].add_song(song)\r\n\r\nclass MusicPlayer:\r\n    def __init__(self):\r\n        self.current_song = None\r\n        self.is_playing = False\r\n\r\n    def play(self, song: Song):\r\n        self.current_song = song\r\n        self.is_playing = True\r\n        print(f\"Playing: {song.title} by {song.artist}\")\r\n\r\n    def pause(self):\r\n        if self.current_song:\r\n            self.is_playing = False\r\n            print(f\"Paused: {self.current_song.title} by {self.current_song.artist}\")\r\n\r\n    def skip(self):\r\n        if self.current_song:\r\n            print(f\"Skipped: {self.current_song.title} by {self.current_song.artist}\")\r\n            self.current_song = None\r\n            self.play_next()\r\n\r\n    def shuffle(self):\r\n        all_songs = library.get_all_songs()\r\n        random_song = random.choice(all_songs)\r\n        self.play(random_song)\r\n\r\n    def play_next(self):\r\n        # For simplicity, assuming play_next is a method to just play the next song\r\n        # For more advanced features, we could maintain a queue or playlist.\r\n        all_songs = library.get_all_songs()\r\n        if all_songs:\r\n            next_song = random.choice(all_songs)\r\n            self.play(next_song)\r\n\r\n# Sample Usage\r\nsong1 = Song(\"Song 1\", \"Artist 1\", \"/music/song1.mp3\")\r\nsong2 = Song(\"Song 2\", \"Artist 2\", \"/music/song2.mp3\")\r\nsong3 = Song(\"Song 3\", \"Artist 3\", \"/music/song3.mp3\")\r\n\r\nlibrary.add_song(song1)\r\nlibrary.add_song(song2)\r\nlibrary.add_song(song3)\r\n\r\nuser = User(\"John\")\r\nuser.create_playlist(\"Favorites\")\r\nuser.add_song_to_playlist(\"Favorites\", song1)\r\nuser.add_song_to_playlist(\"Favorites\", song2)\r\n\r\nplayer = MusicPlayer()\r\nplayer.play(song1)\r\nplayer.pause()\r\nplayer.skip()  # Skips current song and plays the next\r\nplayer.shuffle()  # Plays a random song from the library\r\n",
  "AmazonPackageDelivery.py": "import random\r\nfrom collections import defaultdict\r\n\r\nclass Locker:\r\n    def __init__(self, locker_id, size):\r\n        self.locker_id = locker_id\r\n        self.size = size\r\n        self.occupied_by = None\r\n\r\n    def occupy(self, package_id):\r\n        self.occupied_by = package_id\r\n\r\n    def release(self):\r\n        self.occupied_by = None\r\n\r\nclass Package:\r\n    def __init__(self, package_id, dimensions):\r\n        self.package_id = package_id\r\n        self.dimensions = dimensions\r\n        self.locker_id = None\r\n        self.code = None\r\n\r\nclass LockerManager:\r\n    def __init__(self):\r\n        self.lockers = defaultdict(list)\r\n        self.packages = {}\r\n        self.categories = [10, 20, 30]\r\n\r\n    def add_locker(self, locker):\r\n        self.lockers[max(locker.size)].append(locker)\r\n\r\n    def find_locker(self, package):\r\n        for size in self.categories:\r\n            if max(package.dimensions) <= size:\r\n                return next((locker for locker in self.lockers[size] if not locker.occupied_by), None)\r\n        return None\r\n\r\n    def allocate_locker(self, package):\r\n        if locker := self.find_locker(package):\r\n            locker.occupy(package.package_id)\r\n            package.locker_id, package.code = locker.locker_id, self.generate_code()\r\n            self.packages[package.package_id] = package\r\n            return package.code, locker.locker_id\r\n        return None\r\n\r\n    def release_locker(self, locker_id):\r\n        for size in self.lockers:\r\n            for locker in self.lockers[size]:\r\n                if locker.locker_id == locker_id:\r\n                    locker.release()\r\n                    return True\r\n        return False\r\n\r\n    @staticmethod\r\n    def generate_code():\r\n        return \"\".join(random.choices('ABCDEF1234', k=6))\r\n\r\nclass UserInterface:\r\n    def __init__(self, locker_manager):\r\n        self.locker_manager = locker_manager\r\n\r\n    def pickup_package(self, code):\r\n        for package in self.locker_manager.packages.values():\r\n            if package.code == code:\r\n                locker_id = package.locker_id\r\n                self.locker_manager.release_locker(locker_id)\r\n                del self.locker_manager.packages[package.package_id]\r\n                return f\"✅ Package {package.package_id} picked up from Locker {locker_id}.\"\r\n        return \"❌ Invalid code.\"\r\n\r\nclass DeliveryInterface:\r\n    def __init__(self, locker_manager):\r\n        self.locker_manager = locker_manager\r\n\r\n    def place_package(self, package_id, dimensions):\r\n        package = Package(package_id, dimensions)\r\n        if result := self.locker_manager.allocate_locker(package):\r\n            code, locker_id = result\r\n            return f\"📦 Package {package_id} placed in Locker {locker_id}. Pickup Code: {code}\"\r\n        return \"🚫 No available locker.\"\r\n\r\n\r\n\r\n# 🔹 MAIN EXECUTION (Ensuring a Single LockerManager Instance)\r\nlocker_manager = LockerManager()  # 🔥 SINGLE INSTANCE of LockerManager\r\nuser_interface = UserInterface(locker_manager)\r\ndelivery_interface = DeliveryInterface(locker_manager)\r\n\r\n# Adding lockers of different sizes (Persistent State)\r\nlocker_manager.add_locker(Locker(\"L1\", (10, 10, 10)))\r\nlocker_manager.add_locker(Locker(\"L2\", (20, 20, 20)))\r\nlocker_manager.add_locker(Locker(\"L3\", (30, 30, 30)))\r\n\r\n# Placing packages\r\nprint(delivery_interface.place_package(\"P1\", (8, 8, 8)))  # Should go to 10x10x10 locker\r\nprint(delivery_interface.place_package(\"P2\", (12, 12, 12)))  # Should go to 20x20x20 locker\r\nprint(delivery_interface.place_package(\"P3\", (25, 25, 25)))  # Should go to 30x30x30 locker\r\n\r\n# Attempting to pick up a package (Invalid case)\r\nprint(user_interface.pickup_package(\"INVALID_CODE\"))  # Expected: ❌ Invalid code\r\n\r\n# Picking up a valid package (Replace with actual generated code from above)\r\nprint(user_interface.pickup_package(\"ACTUAL_GENERATED_CODE_HERE\"))\r\n",
  "Blackjack_Game.py": "import random\r\n\r\n# Card class\r\nclass Card:\r\n    def __init__(self, rank, suit):\r\n        self.rank = rank\r\n        self.value = 10 if rank in [\"J\", \"Q\", \"K\"] else 11 if rank == \"A\" else int(rank)\r\n\r\n# Deck class\r\nclass Deck:\r\n    suits = [\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"]\r\n    ranks = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"]\r\n\r\n    def __init__(self):\r\n        self.cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\r\n        random.shuffle(self.cards)\r\n\r\n    def deal(self):\r\n        return self.cards.pop()\r\n\r\n# Player class\r\nclass Player:\r\n    def __init__(self, name):\r\n        self.name = name\r\n        self.hand = []\r\n\r\n    def add_card(self, card):\r\n        self.hand.append(card)\r\n\r\n    def score(self):\r\n        total = sum(card.value for card in self.hand)\r\n        aces = sum(1 for card in self.hand if card.rank == \"A\")\r\n        while total > 21 and aces:\r\n            total -= 10\r\n            aces -= 1\r\n        return total\r\n\r\n# Game class\r\nclass Blackjack:\r\n    def __init__(self, player_name):\r\n        self.deck = Deck()\r\n        self.player = Player(player_name)\r\n        self.dealer = Player(\"Dealer\")\r\n\r\n    def play(self):\r\n        # Deal initial cards\r\n        for _ in range(2):\r\n            self.player.add_card(self.deck.deal())\r\n            self.dealer.add_card(self.deck.deal())\r\n\r\n        # Player's turn\r\n        while (score := self.player.score()) < 21:\r\n            print(f\"Your hand: {[card.rank for card in self.player.hand]}, Score: {score}\")\r\n            action = input(\"Hit or Stand? \").lower()\r\n            if action == \"hit\":\r\n                self.player.add_card(self.deck.deal())\r\n            elif action == \"stand\":\r\n                break\r\n\r\n        # Dealer's turn\r\n        while self.dealer.score() < 17:\r\n            self.dealer.add_card(self.deck.deal())\r\n\r\n        # Final score\r\n        print(f\"Your hand: {[card.rank for card in self.player.hand]}, Score: {self.player.score()}\")\r\n        print(f\"Dealer's hand: {[card.rank for card in self.dealer.hand]}, Score: {self.dealer.score()}\")\r\n\r\n        # Determine winner\r\n        if self.player.score() > 21:\r\n            print(\"You busted! Dealer wins.\")\r\n        elif self.dealer.score() > 21 or self.player.score() > self.dealer.score():\r\n            print(\"You win!\")\r\n        elif self.player.score() == self.dealer.score():\r\n            print(\"It's a tie!\")\r\n        else:\r\n            print(\"Dealer wins!\")\r\n\r\n# Play the game\r\nif __name__ == \"__main__\":\r\n    name = input(\"Enter your name: \")\r\n    game = Blackjack(name)\r\n    game.play()\r\n",
  "Course_Schedule.py": "from typing import List\r\n\r\nclass Course:\r\n    def __init__(self, course_id: int, prerequisites: List[int] = None):\r\n        self.course_id = course_id\r\n        self.prerequisites = prerequisites if prerequisites else []\r\n\r\nclass CourseScheduler:\r\n    def __init__(self, courses: List[Course]):\r\n        self.graph = {course.course_id: course for course in courses}  # Store Course objects\r\n\r\n    def find_course_order(self) -> List[int]:\r\n        visiting, visited = set(), set()\r\n        order = []\r\n\r\n        def dfs(course_id):\r\n            if course_id in visiting:\r\n                return False  # Cycle detected\r\n            if course_id in visited:\r\n                return True  # Already processed\r\n\r\n            visiting.add(course_id)\r\n            for pre in self.graph[course_id].prerequisites:  # Access prerequisites directly\r\n                if not dfs(pre):\r\n                    return False  # Cycle detected\r\n\r\n            visiting.remove(course_id)\r\n            visited.add(course_id)\r\n            order.append(course_id)  # Add after processing dependencies\r\n            return True\r\n\r\n        for course_id in self.graph:\r\n            if course_id not in visited:\r\n                if not dfs(course_id):\r\n                    return []  # Cycle detected\r\n\r\n        return order  # No need to reverse as the order is already correct\r\n\r\n# Example Usage\r\ncourses = [\r\n    Course(0),\r\n    Course(1, [0]),\r\n    Course(2, [0]),\r\n    Course(3, [1, 2])\r\n]\r\n\r\nscheduler = CourseScheduler(courses)\r\nprint(scheduler.find_course_order())  # Output: [0, 1, 2, 3] or another valid order\r\n",
  "LinuxFileSystem.py": "class Node:\r\n    def __init__(self, name, is_dir=False):\r\n        self.name = name\r\n        self.is_dir = is_dir\r\n        self.children = {}  # Directory: name -> Node\r\n        self.data = \"\"  # Only for files\r\n\r\nclass FileSystem:\r\n    def __init__(self):\r\n        self.root = Node(\"/\", is_dir=True)  # Root directory\r\n\r\n    def _get_node(self, path):\r\n        parts = path.strip(\"/\").split(\"/\")\r\n        curr = self.root\r\n        for part in parts:\r\n            if part not in curr.children:\r\n                return None\r\n            curr = curr.children[part]\r\n        return curr\r\n\r\n    def mkdir(self, path):\r\n        parts = path.strip(\"/\").split(\"/\")\r\n        curr = self.root\r\n        for part in parts:\r\n            if part not in curr.children:\r\n                curr.children[part] = Node(part, is_dir=True)\r\n            curr = curr.children[part]\r\n\r\n    def create_file(self, path):\r\n        parts = path.strip(\"/\").split(\"/\")\r\n        filename = parts.pop()\r\n        parent = self._get_node(\"/\" + \"/\".join(parts))\r\n        if not parent or not parent.is_dir:\r\n            print(f\"Invalid path: {path}\")\r\n            return\r\n        parent.children[filename] = Node(filename, is_dir=False)\r\n\r\n    def write_file(self, path, data):\r\n        file = self._get_node(path)\r\n        if not file or file.is_dir:\r\n            print(f\"Invalid file: {path}\")\r\n            return\r\n        file.data = data\r\n\r\n    def read_file(self, path):\r\n        file = self._get_node(path)\r\n        if not file or file.is_dir:\r\n            print(f\"File not found: {path}\")\r\n            return\r\n        print(f\"Reading '{path}': {file.data}\")\r\n\r\n    def find(self, name, node=None, path=\"\"):\r\n        if node is None:\r\n            node = self.root\r\n        if node.name == name:\r\n            print(f\"Found at: {path or '/'}\")\r\n        for child in node.children.values():\r\n            self.find(name, child, f\"{path}/{child.name}\")\r\n\r\n# Test the tree-based file system\r\nfs = FileSystem()\r\nfs.mkdir(\"/home/user\")\r\nfs.create_file(\"/home/user/file1.txt\")\r\nfs.write_file(\"/home/user/file1.txt\", \"Hello, Linux!\")\r\nfs.read_file(\"/home/user/file1.txt\")\r\nfs.find(\"file1.txt\")\r\nfs.find(\"user\")\r\n",
  "PakingLot.py": "class ParkingSpot:\r\n    def __init__(self, spot_id, spot_type):\r\n        self.spot_id = spot_id\r\n        self.spot_type = spot_type\r\n        self.vehicle = None  # No vehicle initially.\r\n\r\n    def assign_vehicle(self, vehicle):\r\n        if self.vehicle is None:\r\n            self.vehicle = vehicle\r\n            return True\r\n        return False\r\n\r\n    def remove_vehicle(self):\r\n        if self.vehicle is not None:\r\n            self.vehicle = None\r\n            return True\r\n        return False\r\n\r\n    def is_empty(self):\r\n        return self.vehicle is None\r\n\r\n\r\nclass Vehicle:\r\n    def __init__(self, license_plate, vehicle_type):\r\n        self.license_plate = license_plate\r\n        self.vehicle_type = vehicle_type\r\n        self.entry_time = None  # Time can be set when vehicle enters the lot.\r\n\r\n    def get_vehicle_details(self):\r\n        return f\"License Plate: {self.license_plate}, Type: {self.vehicle_type}\"\r\n\r\n\r\nclass ParkingLot:\r\n    def __init__(self, capacity, spot_types=['compact', 'regular', 'oversized']):\r\n        self.capacity = capacity\r\n        self.occupied_count = 0\r\n        self.parking_spots = []\r\n        # Create parking spots with different types (compact, regular, oversized).\r\n        for i in range(capacity):\r\n            spot_type = spot_types[i % len(spot_types)]  # Cycling through the types\r\n            self.parking_spots.append(ParkingSpot(i, spot_type))\r\n\r\n    def find_available_spot(self, vehicle_type):\r\n        for spot in self.parking_spots:\r\n            if spot.is_empty() and spot.spot_type == vehicle_type:\r\n                return spot\r\n        return None  # No available spot for this type.\r\n\r\n    def add_vehicle(self, vehicle):\r\n        spot = self.find_available_spot(vehicle.vehicle_type)\r\n        if spot:\r\n            spot.assign_vehicle(vehicle)\r\n            self.occupied_count += 1\r\n            return f\"Vehicle {vehicle.license_plate} parked at spot {spot.spot_id}.\"\r\n        return \"No available spot for this vehicle.\"\r\n\r\n    def remove_vehicle(self, vehicle):\r\n        for spot in self.parking_spots:\r\n            if spot.vehicle == vehicle:\r\n                spot.remove_vehicle()\r\n                self.occupied_count -= 1\r\n                return f\"Vehicle {vehicle.license_plate} removed from spot {spot.spot_id}.\"\r\n        return \"Vehicle not found.\"\r\n\r\n    def is_full(self):\r\n        return self.occupied_count == self.capacity\r\n\r\n    def get_available_spots(self):\r\n        return len([spot for spot in self.parking_spots if spot.is_empty()])\r\n\r\n\r\n# Example Usage:\r\nparking_lot = ParkingLot(10)\r\nvehicle1 = Vehicle(\"XYZ123\", \"compact\")\r\nvehicle2 = Vehicle(\"ABC456\", \"regular\")\r\n\r\nprint(parking_lot.add_vehicle(vehicle1))  # Vehicle XYZ123 parked at spot 0.\r\nprint(parking_lot.add_vehicle(vehicle2))  # Vehicle ABC456 parked at spot 1.\r\nprint(parking_lot.remove_vehicle(vehicle1))  # Vehicle XYZ123 removed from spot 0.\r\n",
  "Pizza.py": "from abc import ABC, abstractmethod\r\n\r\n#abstract pizza component\r\nclass Pizza(ABC):\r\n    @abstractmethod\r\n    def get_description(self):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def get_cost(self):\r\n        pass\r\n\r\n#concrete base pizzas with size\r\nclass ThinCrustPizza(Pizza):\r\n    def __init__(self, size):\r\n        self.size=size\r\n        self.baseprice=self._set_base_price()\r\n\r\n    def _set_base_price(self):\r\n        size_prices={\"Small\": 5, \"Mid\":7, \"Large\":9}\r\n        return size_prices.get(self.size)\r\n    \r\n    def get_description(self):\r\n        return f\"{self.size} Thin Crust Pizza\"\r\n    \r\n    def get_cost(self):\r\n        return self.baseprice\r\n    \r\n\r\n''' .... add other bases, just change the base price map and description'''\r\n\r\n#decorator abstract class\r\nclass PizzaDecorator(Pizza):\r\n    def __init__(self,pizza):\r\n        self.pizza=pizza\r\n\r\n    def get_description(self):\r\n        return self.pizza.get_description()\r\n\r\n    def get_cost(self):\r\n        return self.pizza.get_cost()     \r\n\r\n#concrete decorators\r\nclass Cheese(PizzaDecorator):\r\n    def get_description(self):\r\n        return self.pizza.get_description() + \", Cheese\"\r\n    def get_cost(self):\r\n        return self.pizza.get_cost() + 2\r\n    \r\n'''....add other toppings, just change the name and incremental price'''\r\n\r\n\r\n# Step 5: Client Code (Ordering Pizza)\r\npizza = ThinCrustPizza(\"Large\")  # Choose base: ThinCrustPizza or StuffedCrustPizza\r\npizza = Cheese(pizza)\r\n\r\nprint(f\"Order: {pizza.get_description()} - Cost: ${pizza.get_cost()}\")",
  "Rate Limiter.py": "from collections import deque\r\nfrom datetime import datetime, timedelta\r\n\r\nclass RateLimiter:\r\n    def __init__(self, log_file, max_requests, time_window):\r\n        self.log_file = log_file\r\n        self.max_requests = max_requests\r\n        self.time_window = timedelta(seconds=time_window)\r\n        self.user_requests = {}\r\n\r\n    def process_logs(self):\r\n        \"\"\"Reads log file and stores user request timestamps.\"\"\"\r\n        with open(self.log_file, 'r') as file:\r\n            for line in file:\r\n                user, timestamp = line.strip().split(\", \")\r\n                timestamp = datetime.fromisoformat(timestamp)\r\n                \r\n                if user not in self.user_requests:\r\n                    self.user_requests[user] = deque()\r\n                \r\n                self.user_requests[user].append(timestamp)\r\n\r\n    def can_make_request(self, user, current_time):\r\n        \"\"\"Checks if the user can make another request based on rate limits.\"\"\"\r\n        if user not in self.user_requests:\r\n            return True\r\n        \r\n        request_queue = self.user_requests[user]\r\n\r\n        # Remove old requests outside the time window\r\n        while request_queue and request_queue[0] < current_time - self.time_window:\r\n            request_queue.popleft()\r\n\r\n        return len(request_queue) < self.max_requests\r\n\r\n# Example Usage\r\nlog_file = \"api_logs.txt\"\r\nrate_limiter = RateLimiter(log_file, max_requests=3, time_window=5)  # 3 requests per 5 seconds\r\nrate_limiter.process_logs()\r\n\r\n# Checking if User1 can make a request at a specific time\r\ncurrent_time = datetime.fromisoformat(\"2024-02-18T12:00:08\")\r\nprint(rate_limiter.can_make_request(\"User1\", current_time))  # Output: True or False\r\n",
  "TicTacToe.py": "import random\r\n\r\nclass Board:\r\n    def __init__(self):\r\n        self.grid = [[\" \" for _ in range(3)] for _ in range(3)]\r\n\r\n    def display(self):\r\n        for row in self.grid:\r\n            print(\"|\".join(row))\r\n            print(\"-\" * 5)\r\n\r\n    def make_move(self, row, col, symbol):\r\n        if 0 <= row < 3 and 0 <= col < 3 and self.grid[row][col] == \" \":\r\n            self.grid[row][col] = symbol\r\n            return True\r\n        return False\r\n\r\n    def is_winner(self, symbol):\r\n        for i in range(3):\r\n            if all(self.grid[i][j] == symbol for j in range(3)):  # Check rows\r\n                return True\r\n            if all(self.grid[j][i] == symbol for j in range(3)):  # Check columns\r\n                return True\r\n        if all(self.grid[i][i] == symbol for i in range(3)):  # Check main diagonal\r\n            return True\r\n        if all(self.grid[i][2 - i] == symbol for i in range(3)):  # Check opposite diagonal\r\n            return True\r\n        return False\r\n\r\n    def is_full(self):\r\n        return all(cell != \" \" for row in self.grid for cell in row)\r\n\r\n\r\nclass Player:\r\n    def __init__(self, symbol):\r\n        self.symbol = symbol\r\n\r\n    def get_move(self):\r\n        while True:\r\n            move = input(f\"Enter row and col (0-2) for {self.symbol}: \").split()\r\n            if len(move) == 2 and all(x.isdigit() for x in move):\r\n                row, col = map(int, move)\r\n                if 0 <= row < 3 and 0 <= col < 3:\r\n                    return row, col\r\n            print(\"Invalid input! Enter two numbers between 0-2.\")\r\n\r\n\r\nclass Game:\r\n    def __init__(self):\r\n        self.board = Board()\r\n        self.players = [Player(\"X\"), Player(\"O\")]\r\n        self.current_player = random.choice(self.players)\r\n\r\n    def switch_turn(self):\r\n        self.current_player = self.players[0] if self.current_player == self.players[1] else self.players[1]\r\n\r\n    def play(self):\r\n        while True:\r\n            self.board.display()\r\n            row, col = self.current_player.get_move()\r\n\r\n            if self.board.make_move(row, col, self.current_player.symbol):\r\n                if self.board.is_winner(self.current_player.symbol):\r\n                    self.board.display()\r\n                    print(f\"🎉 Player {self.current_player.symbol} wins!\")\r\n                    break\r\n                if self.board.is_full():\r\n                    self.board.display()\r\n                    print(\"It's a draw!\")\r\n                    break\r\n                self.switch_turn()\r\n            else:\r\n                print(\"Invalid move, try again!\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    Game().play()\r\n",
  "UI.py": "class View:\r\n    def __init__(self, id=None):\r\n        self.id = id\r\n        self.children = []\r\n\r\n    def add_view(self, view):\r\n        self.children.append(view)\r\n\r\ndef find_view_by_id(root, target_id):\r\n    if root.id == target_id:\r\n        return root\r\n    for child in root.children:\r\n        found = find_view_by_id(child, target_id)\r\n        if found:\r\n            return found\r\n    return None\r\n\r\n\r\n# Example usage\r\nroot = View(\"content\")\r\ninner = View(\"inner\")\r\ntext_view = View(\"primary_text\")\r\n\r\nroot.add_view(inner)\r\ninner.add_view(text_view)\r\n\r\nfound = find_view_by_id(root, \"primary_text\")\r\nprint(f\"Found primary_text: {found is not None}\")  # Output: True"
}